// =======================
// üì¶ IMPORTA√á√ïES
// =======================
import {
  makeWASocket,
  useMultiFileAuthState,
  DisconnectReason,
  delay,
  fetchLatestBaileysVersion
} from '@whiskeysockets/baileys';
import { Boom } from '@hapi/boom';

import { initializeApp } from 'firebase/app';
import {
  getFirestore,
  collection,
  query,
  where,
  getDocs
} from 'firebase/firestore/lite';

// =======================
// üîß CONFIGURA√á√ÉO DO FIREBASE
// =======================
const firebaseConfig = {
  apiKey: "AIzaSyAHG-CSJzOhmuYpjM9i6cEqBJtGDqxuSD8",
  authDomain: "bicudos-c9ff0.firebaseapp.com",
  projectId: "bicudos-c9ff0",
  storageBucket: "bicudos-c9ff0.appspot.com",
  messagingSenderId: "81469971834",
  appId: "1:81469971834:web:43100abd81b5b3d2e80ac3",
  measurementId: "G-JT1CX0HTKB"
};

const firebaseApp = initializeApp(firebaseConfig);
const db = getFirestore(firebaseApp);

// =======================
// üóÇÔ∏è VARI√ÅVEIS GLOBAIS
// =======================
const sessions = {};
const cepPrefixMap = {
  "90": "porto alegre",
  "91": "porto alegre",
  "92": "canoas",
  "95": "pelotas",
  "11": "s√£o paulo",
  "22": "rio de janeiro",
  "30": "belo horizonte"
};

// =======================
// üß∞ UTILIT√ÅRIOS
// =======================
const getServicosDisponiveis = async () => {
  const snapshot = await getDocs(collection(db, "profissionais"));
  const servicosSet = new Set();
  snapshot.forEach(doc => {
    const dados = doc.data();
    if (Array.isArray(dados.servico)) {
      dados.servico.forEach(s => servicosSet.add(s));
    }
  });
  return Array.from(servicosSet).sort();
};

const mostrarProfissionais = async (sock, sender, snapshot) => {
  let resposta = "‚ú® Profissionais dispon√≠veis no momento:\n\n";

  snapshot.forEach(doc => {
    const p = doc.data();
    const numeroLimpo = (p.telefone || "").replace(/\D/g, '');
    const link = numeroLimpo ? `https://wa.me/55${numeroLimpo}` : null;

    resposta += `üë§ Nome: ${p.nome}\n`;
    resposta += link
      ? `üìû Contato: ${link}\n`
      : `üìû Contato: N√£o informado\n`;
    resposta += `‚≠ê Avalia√ß√£o: ${p.nota ?? "Sem nota"}\n`;
    resposta += `üìù Sobre: ${p.descricao}\n\n`;
  });

  resposta += "Posso ajudar com mais alguma coisa? (sim/n√£o) ü¶Ü";
  await sock.sendMessage(sender, { text: resposta });
};

// =======================
// ü§ñ CONEX√ÉO WHATSAPP
// =======================
const connectToWhatsApp = async () => {
  const { state, saveCreds } = await useMultiFileAuthState('auth_info_baileys');
  const { version } = await fetchLatestBaileysVersion();

  const sock = makeWASocket({
    version,
    auth: state,
    printQRInTerminal: true
  });

  sock.ev.on('creds.update', saveCreds);

  sock.ev.on('connection.update', ({ connection, lastDisconnect }) => {
    if (connection === 'close') {
      const shouldReconnect =
        (lastDisconnect?.error instanceof Boom
          ? lastDisconnect.error.output?.statusCode
          : 0) !== DisconnectReason.loggedOut;

      console.log('üîå Conex√£o encerrada', shouldReconnect ? 'üîÑ Reconectando...' : '‚õî Deslogado');
      if (shouldReconnect) connectToWhatsApp();
    } else if (connection === 'open') {
      console.log('‚úÖ Conectado ao WhatsApp! üéâ');
    }
  });

  sock.ev.on('messages.upsert', async ({ messages }) => {
    const msg = messages[0];
    if (!msg.message || msg.key.fromMe) return;

    const sender = msg.key.remoteJid;
    const text = msg.message.conversation || msg.message.extendedTextMessage?.text || '';

    if (!sessions[sender]) sessions[sender] = { step: 0, data: {} };

    if (sessions[sender].timeout) clearTimeout(sessions[sender].timeout);
    sessions[sender].timeout = setTimeout(() => {
      sock.sendMessage(sender, {
        text: "Tudo bem por a√≠? Vou encerrar nosso papo por enquanto. Quando quiser, √© s√≥ me chamar de novo. ü¶Ü"
      });
      delete sessions[sender];
    }, 5 * 60 * 1000);

    const session = sessions[sender];

    switch (session.step) {
      case 0:
        await sock.sendMessage(sender, {
          text: `Oi! Eu sou o Bico, seu assistente para encontrar profissionais incr√≠veis pertinho de voc√™. üíºü¶Ü\n\nEstou em vers√£o beta, ent√£o se algo parecer estranho, voc√™ pode me ajudar com sugest√µes aqui:\nüìã https://forms.gle/43j6g39jTyJNFvyG6\n\nVamos come√ßar? Me diz como posso te chamar. üòÑ`
        });
        session.step = 1;
        break;

      case 1:
        session.data.nome = text.trim();
        const servicos = await getServicosDisponiveis();

        if (servicos.length === 0) {
          await sock.sendMessage(sender, {
            text: "No momento n√£o temos servi√ßos cadastrados. Volte daqui a pouquinho! üòâ"
          });
          delete sessions[sender];
          return;
        }

        session.data.servicoOptions = servicos;
        const opcoesTexto = servicos.map((s, i) => `${i + 1}. ${s}`).join('\n');

        await sock.sendMessage(sender, {
          text: `Prazer, ${session.data.nome}! üòÑ Escolha o servi√ßo que voc√™ est√° buscando:\n\n${opcoesTexto}`
        });
        session.step = 2;
        break;

      case 2:
        const index = parseInt(text.trim(), 10) - 1;
        const servico = session.data.servicoOptions?.[index];
        if (!servico) {
          await sock.sendMessage(sender, {
            text: 'Por favor, envie s√≥ o n√∫mero do servi√ßo que voc√™ quer. ü¶Ü'
          });
          return;
        }
        session.data.servico = servico;
        await sock.sendMessage(sender, {
          text: 'Agora me manda seu CEP pra eu buscar os profissionais mais pr√≥ximos. üó∫Ô∏è'
        });
        session.step = 3;
        break;

      case 3:
        session.data.cep = text.trim();
        const prefixo = session.data.cep.slice(0, 5);
        const profissionaisRef = collection(db, "profissionais");

        try {
          const buscaPorCep = query(
            profissionaisRef,
            where("servico", "array-contains", session.data.servico),
            where("cep_prefixo", "==", parseInt(prefixo, 10))
          );
          const resultado = await getDocs(buscaPorCep);

          if (!resultado.empty) {
            await mostrarProfissionais(sock, sender, resultado);
            session.step = 5;
          } else {
            const cidade = cepPrefixMap[session.data.cep.slice(0, 2)];
            if (cidade) {
              const buscaCidade = query(
                profissionaisRef,
                where("servico", "array-contains", session.data.servico),
                where("cidade", "==", cidade)
              );
              const resCidade = await getDocs(buscaCidade);

              if (!resCidade.empty) {
                await mostrarProfissionais(sock, sender, resCidade);
                session.step = 5;
              } else {
                await sock.sendMessage(sender, {
                  text: "Hmm, n√£o encontrei ningu√©m com esse CEP. Qual o nome da sua cidade? (ex: S√£o Paulo) ü¶Ü"
                });
                session.step = 6;
              }
            } else {
              await sock.sendMessage(sender, {
                text: "N√£o consegui identificar a cidade pelo CEP. Me diga o nome dela (ex: S√£o Paulo). ü¶Ü"
              });
              session.step = 6;
            }
          }
        } catch (err) {
          console.error("Erro ao buscar profissionais:", err);
          await sock.sendMessage(sender, {
            text: "Tivemos um probleminha aqui... pode tentar de novo em instantes? ü¶Ü"
          });
          session.step = 0;
        }
        break;

      case 6:
        session.data.cidade = text.trim().toLowerCase();
        try {
          const buscaCidadeManual = query(
            collection(db, "profissionais"),
            where("servico", "array-contains", session.data.servico),
            where("cidade", "==", session.data.cidade)
          );
          const resultado = await getDocs(buscaCidadeManual);

          if (resultado.empty) {
            await sock.sendMessage(sender, {
              text: "Poxa, ainda n√£o temos profissionais nessa cidade. Quer tentar outra? (sim/n√£o)"
            });
            session.step = 4;
          } else {
            await mostrarProfissionais(sock, sender, resultado);
            session.step = 5;
          }
        } catch (err) {
          console.error("Erro ao buscar por cidade:", err);
          await sock.sendMessage(sender, {
            text: "Algo deu errado na busca... me perdoa! ü¶Ü"
          });
          session.step = 0;
        }
        break;

      case 4:
        if (text.toLowerCase() === 'sim') {
          await sock.sendMessage(sender, {
            text: 'Me manda outro CEP que eu tento de novo! ü¶Ü'
          });
          session.step = 3;
        } else {
          await sock.sendMessage(sender, {
            text: 'Obrigado por conversar comigo! At√© a pr√≥xima. üëã'
          });
          delete sessions[sender];
        }
        break;

      case 5:
        if (text.toLowerCase() === 'sim') {
          const servicos = await getServicosDisponiveis();
          if (servicos.length === 0) {
            await sock.sendMessage(sender, {
              text: "No momento n√£o temos outros servi√ßos. Volte em breve, t√° bom? ü¶Ü"
            });
            delete sessions[sender];
            return;
          }

          session.data.servicoOptions = servicos;
          const opcoesTexto = servicos.map((s, i) => `${i + 1}. ${s}`).join('\n');

          await sock.sendMessage(sender, {
            text: `Claro! Escolha o pr√≥ximo servi√ßo que voc√™ precisa:\n\n${opcoesTexto}`
          });
          session.step = 2;
        } else {
          await sock.sendMessage(sender, {
            text: 'Foi um prazer te ajudar! Volte quando quiser. ü¶Ü'
          });
          delete sessions[sender];
        }
        break;
    }
  });
};

process.on('unhandledRejection', reason => {
  console.error('üö® Unhandled Rejection:', reason);
});

connectToWhatsApp();
